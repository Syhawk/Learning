《重构》
I. 重构案例小技巧
	1. 如果你发现自己需要为程序添加一个特性，而代码结构使你无法很方便地达成目的，
		那就先重构那个程序，使特性的添加比较容易进行，然后再添加特性
	2. 重构前，先检查自己是否有一套可靠的测试机制。这些测试必须有自我检验能力
	3. 重构技术就是以微小的步伐修改程序。如果你犯下错误，很容易便可发现它
	4. 任何一个傻瓜都能写出计算机可以理解代码。唯有写出人类容易理解的代码，才是优秀的程序员

II. 重构原则
	1. 重构：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本
	2. 重构时机
		1）事不过三，三则重构
		2）添加功能时重构
		3）修补错误时重构
		4）复审代码时重构
	3. 编写快速软件的方法
		1）时间预算法：这通常只用于性能要求极高的实时系统
		2）持续关注法：这种方法要求任何程序员在任何时间做任何事时，都要设法保持系统的高性能
		3）性能提升法：优化程序集中80%+的时间运行的代码

III. 代码腐朽表现
	1. 重复代码
	2. 过长函数
	3. 过大的类
	4. 过长参数列
	5. 发散式变化（每当加入新功能，就需要作出部分修改）
	6. 散弹式修改（每遇到某种变化，都必须在许多不同的类内做出很多小修改）
	7. 依恋情结（函数对某个类的兴趣高过于对自己所处类的兴趣）
	8. 数据泥团（代码很多地方出现相同属性，函数中参数相同）
	9. 基本类型偏执（经常使用基本类型，而不抽离成类象）
	10. switch惊悚现身
	11. 平行继承体系（某个继承体系前缀与另一个继承体系前缀一致）
	12. 冗赘类
	13. 不必要的防御性（用不到的各种hook和特殊情况处理）
	14. 暂时性属性（为某种特定情况而设的属性）
	15. 过度耦合的消息链
	16. 过度委托
	17. 狎昵关系（花费过多时间探究彼此的private成分）
	18. 异曲同工的类
	19. 不完美的库类（第三方库等不满足现在需求）
	20. 数据类属性完全公开
	21. 被拒绝的遗赠（子类限制使用超类的遗产）
	22. 过多的注释

IV. 构建测试体系
	1. 确保所有测试都完全自动化，让它们检查自己的测试结果
	2. 一套测试就是一个强大的bug侦测器，能够大大缩减查找bug所需要的时间
	3. 建立一个独立类用于测试，并在一个框架中运行它，使测试工作更轻松
	4. 频繁地运行测试，每次编译请把测试也考虑进去——每天至少执行每个测试一次
	5. 每当收到bug报告，先写一个单元测试来暴露这个bug
	6. 测试你最担心出错的地方
	7. 编写未臻完善的测试并实际运行，好过对完美测试的无尽等待
	8. 考虑可能出错的边界条件，把测试火力集中在那儿
	9. 当事情被认为应该会出错时，别忘了检查是否抛出了预期的异常
	10. 不要因为测试无法捕捉所有的bug就不写测试，因为测试的确可以捕捉到大多数的bug

V. 重新组织函数
	1. Extract Method（提炼函数）
		动机：函数过长
		意义：1）函数粒度足够小，复用机会更大
			  2）使高层函数读起来就像一系列注释
			  3）函数复写也会更容易
	    做法：1）创造一个新函数，并以函数意图来命名
	    	  2）将提炼出的代码从源函数复制到新建的目标函数中
	    	  3）仔细检查提炼出的代码，变量是否引用了“作用域限于源函数”
	    	  4）检查是否有“仅用于被提炼函数”的临时变量
	    	  5）检查被提炼代码，是否有任何局部变量的值被改变
	    	  6）将被提炼代码中需要读取的局部变量，当作参数传给目标函数
	    	  7）处理完所有局部变量之后，进行编译
	    	  8）在源函数中，将被提炼代码段替换为对目标函数的调用
	    	  9）编译，测试
    2. Inline Method（内联函数）
    	动机：一群组织不甚合理的函数
    	做法：1）检查函数，确定它不具多态性
    		  2）找出这个函数的所有被调用点
    		  3）将这个函数的所有被调用点都替换为函数本体
    		  4）编译，测试
    		  5）删除该函数的定义
    3. Inline Temp（内联临时变量）
    	动机：某个临时变量被赋予某个函数调用的返回值
    	做法：1）检查给临时变量赋值的语句，确保等号右边的表达式没有副作用
    		  2）如果这个临时变量并未被声明位final，那就将它声明为final，然后编译
    		  3）找到临时变量的所有引用点，将它们替换为“为临时变量赋值”的表达式
    		  4）每次修改后，编译并测试
    		  5）修改完所有引用点之后，删除该临时变量的声明和赋值语句
    		  6）编译，测试
	4. Replace Temp with Query（以查询取代临时变量）
		动机：它们是暂时的，而且只能在所属函数内使用
		做法：1）找出只被赋值一次的临时变量
			  2）将该临时变量声明为final
			  3）编译
			  4）将“对该临时变量赋值”语句的等号右侧部分提炼到一个独立函数
			  5）编译，测试
			  6）在该临时变量身上实施Inline Temp
    5. Introduce Explaining Variable（引入解释性变量）
    	动机：表达式复杂到难以阅读
    	做法：1）声明一个final临时变量，将待分解之复杂表达式中的一部分动作的运算结果赋值给它
    		  2）将表达式中的“运算结果”这一部分，替换为上述临时变量
    		  3）编译，测试
    		  4）重复上述过程，处理表达式的其他部分
	6. Split Temporary Variable（分解临时变量）
		动机：一个临时变量承担多个责任
		做法：1）在待分解临时变量的声明及第一次被赋值处，修改其名称
			  2）将新的临时变量声明为final
			  3）以该临时变量的第二次赋值动作为界，修改此前对该临时变量的所有引用点，让它们引用新的临时变量
			  4）在第二次赋值处，重新声明原先那个临时变量
			  5）编译，测试
			  6）主次重复上述过程。每次都在声明处对临时变量改名，并修改下次赋值之前的引用点
    7. Remove Assignments to Parameters（移除对参数的赋值）
    	动机：对参数赋值
		做法：1）建立一个临时变量，把待处理的参数值赋予它
			  2）以“对参数的赋值”为界，将其后所有对此参数的引用点，全部替换为“对此临时变量的引用”
			  3）修改赋值语句，使其改为新建之临时变量赋值
			  4）编译，测试
	8. Replace Method with Method Object（以函数对象取代函数）
		动机：局部变量泛滥成灾，分解函数困难
		做法：1）建立一个新类，根据待处理函数的用途，为这个函数命名
			  2）在新类中建立一个final属性，用以保存原先大型函数所在的对象；
		  		同时，针对原函数的每个临时变量和参数，在新类中建立一个对应的属性保存。
		  	  3）在新类中建立一个构造函数，接收源对象及原函数的所有参数作为参数
		  	  4）在新类中建立一个compute()函数
		  	  5）将原函数的代码复制到compute()函数中
		  	  6）编译
		  	  7）将旧函数的函数本体替换为这样一条语句：“创建上述新类的一个新对象，而后调用其中的compute()函数”
  	9. Substitute Algorithm（替换算法）
  		动机：发现做一件事可以有更清晰的方式
  		做法：1）准备好另一个（替换用）算法，让它通过编译
  			  2）针对现有测试，执行上述的新算法。如果结果与原本结果相同，重构结束
  			  3）如果测试结果不同于原先，在测试和调试过程中，以旧算法为比较参照标准

VI. 对象之间搬移特性
	1. Move Method（搬移函数）
		动机：一个类有太多行为，或与另一个类有太多合作而形成高度耦合
		做法：1）检查源类中被源函数所使用的一切特性（属性和函数），考虑他们是否也该被搬移
			  2）检查源类的子类和超类，看看是否有该函数的其它声明
			  3）在目标类中声明该函数
			  4）将源函数的代码复制到目标函数中。调整后者，使其能在新家中正常运行
			  5）编译目标类
			  6）决定如何从源函数正确引用目标对象
			  7）修改源函数，使之成为一个纯委托函数
			  8）编译，测试
			  9）决定是否删除源函数，或将它当作一个委托函数保留下来
			  10）如果要移除源函数，请将源类中对源函数的所有调用，替换为对目标函数的调用
	2. Move Field（搬移属性）
		动机：对于一个属性，在其所驻类之外的另一个类中有更多函数使用了它
		做法：1）如果属性的访问级是public，使用Encapsulate Field将它封装起来
			  2）编译，测试
			  3）在目标类中建立与源属性相同的属性，并同时建立相应的设置/取值函数
			  4）编译目标类
			  5）决定如何在源对象中引用目标对象
			  6）删除源属性
			  7）将所有对源属性的引用替换为对某个目标函数的调用
    3. Extract Class（提炼类）
    	动机：某些数据总是和某些函数一起出现，某些数据经常同时变化甚至彼此相依
    	做法：1）决定如何分解类所负的责任
    		  2）建立一个新类，用以表现从旧类中分离出来的责任
    		  3）建立“从旧类访问新类”的连接关系
    		  4）对于你想搬移的每一个属性，运用Move Field搬移
    		  5）每次半以后，编译，测试
    		  6）使用Move Method将必要函数搬移到新类。先搬移较低层函数，再搬移较高层函数
    		  7）每次搬移之后，编译，测试
    		  8）检查，精简每个类的接口
    		  9）决定是否公开新类。如果公开，就要决定让它成为引用对象还是不可改变的值对象
	4. Inline Class（将类内联化）
		动机：一个类不再承担足够责任，不再有单独存在的理由
		方法：1）在目标类身上声明源类的public协议，并将其中所有函数委托至源类
			  2）修改所有源类引用点，改而引用目标类
			  3）编译，测试
			  4）运用Move Method和Move Field，将源类的特性全部搬移到目标类
			  5）为源类举行一个简单的“丧礼”
    5. Hide Delegate（隐藏“委托关系”）
    	动机：某个客户先通过服务对象的属性的到另一个对象，然后调用后者的函数，客户必须知晓这一层委托关系
    	方法：1）对于每一个委托关系中的函数，在服务对象端建立一个简单的委托函数
    	      2）调整客户，令它只调用服务对象提供的函数
    	      3）每次调整后，编译并测试
    	      4）如果将来不再有任何客户需要取用Delegate（委托类），便可移除服务对象中的相关访问函数
    	      5）编译，测试
    6. Remove Middle Man（移除中间人）
    	动机：委托类的特性过多
    	做法：1）建立一个函数，用以获得受托对象
    		  2）对于每个委托函数，在服务类中删除该函数，并让需要调用该函数的客户转为调用受托对象
    		  3）处理每个委托函数后，编译，测试
    7. Introduce Foreign Method（引入外加函数）
    	动机：客户建立一个函数，并以第一参数形式传入一个服务类实例
    	做法：1）在客户中建立一个函数，用来提供你需要的功能
    		  2）以服务类实例作为该函数的第一个参数
    		  3）将该函数注释为：“外加函数（foreign method），应在服务类实现”
	8. Introduce Local Extension（引入本地扩展）
		动机：需要为服务类提供一些额外函数，但你无法修改这个类
		做法：1）建立一个扩展类，将它作为原始类的子类或包装类
			  2）在扩展类中加入转型构造函数
			  3）在扩展类中加入新特性
			  4）根据需求，将源对象替换为扩展对象
			  5）将针对原始类定义的所有外加函数搬移到扩展类中

VII. 重新组织数据
	1. Self Encapsulate Field（自封装属性）
		动机：直接访问一个属性，但与属性之间的耦合关系逐渐变得笨拙
		做法：1）为待封装属性建立取值/设值函数
			  2）找出该属性的所有引用点，将它们全部改为调用取值/设值函数
			  3）将该属性声明为private
			  4）复查，确保找出所有引用点
			  5）编译，测试
	2. Replace Data Vaule with Object（以对象取代数据值）
		动机：数据项需要与其他数据和行为一起使用才有意义
		做法：1）为待替换数值新建一个类，在其中声明一个final属性，其类型和源类中的待替换数值类型一致。
				然后在新类中加入这个属性的取值函数，再加上一个接收此属性为参数的构造函数
			  2）编译
			  3）将源类中的待替换属性的类型改为前面新建的类
			  4）修改原来中该属性的取值函数，令它调用新类的取值函数
			  5）如果源类构造函数中用到这个待替换属性，就修改构造函数，令它改用新类的构造函数来对属性进行赋值
			  6）修改源类中待替换属性的设值函数，令它为新类创建一个实例
			  7）编译，测试
			  8）可能需要对新类使用Change Value to Reference
	3. Change Value to Reference（将值对象改为引用对象）
		动机：从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象
		做法：1）使用Replace Constructor with Factory Method
			  2）编译，测试
			  3）决定由什么对象负责提供访问新对象的途径
			  4）决定经这些引用对象应该预先创建好，或是应该动态创建
			  5）修改工厂函数，令它返回引用对象
			  6）编译，测试
	4. Change Reference to Vaule（将引用对象改为值对象）
		动机：有一个引用对象，很小且不改变，而且不易管理
		做法：1）检查重构目标是否为不可变对象，或是可修改为不可变对象
			  2）建立equals()和hashCode()函数
			  3）编译，测试
			  4）考虑是否可以删除工厂函数，并将构造函数声明为public
	5. Replace Array with Object（以对象取代数组）
		动机：有一个数组，其中的元素各自代表不同的东西
		做法：1）新建一个类表示数组所拥有的信息，并在其中以一个public属性保存原先的数组
			  2）修改数组的所有用户，让它们改用新类的实例
			  3）编译，测试
			  4）逐一为数组元素添加取值/设值函数。根据元素的用途，为这些访问函数命名。修改客户端代码，
			  	让它们通过访问函数取用数组内的元素。每次修改后，编译并测试
			  5）当所有数组的直接访问都转而调用访问数组后，将新类中保存该数组的属性声明为private
			  6）编译
			  7）对于数组内的每一个元素，在新类中创建一个类型相当的属性。修改该元素的访问函数，
			  	令它改用上述的新建属性
		  	  8）每修改一个元素，编译并测试
		  	  9）数组的所有元素都有了相应属性之后，删除该数组
  	6. Duplicate Observed Data（复制“被监视数据”）
  		动机：一些领域数据置身于GUI控件中，而领域函数需要访问这些数据
  		做法：1）修改展现类，使其成为领域类的Observer
  			  2）针对GUI类中的领域数据，使用Self Encapsulate Field
  			  3）编译，测试
  			  4）在事件处理函数中调用设值函数，直接更新GUI组件
  			  5）编译，测试
  			  6）在领域类中定义数据及其相关访问函数
  			  7）修改展现类中的访问函数，将它们的操作对象改为领域对象
  			  8）修改Observer的update()，使其从相应的领域对象中将所需数据复制给GUI组件
  			  9）编译，测试
	7. Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）
		动机：两个类都需要使用对象特性，但其间只有一条单向链接
		做法：1）在被引用类中增加一个属性，用以保存反向指针
			  2）决定由哪个类——引用端还是被引用端——控制关联关系
			  3）在被控端建立一个辅助函数，其命名应该清楚指出他们的有限用途
			  4）如果既有的修改函数在控制端，让它们负责更新反向指针
			  5）如果既有的修改函数在被控端，就在控制端建立一个控制函数，
			  	并让既有的修改函数调用这个新建的控制函数
  	8. Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）
  		动机：两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性
  		做法：1）找出保存“你想去除的指针”的属性，检查它的每一个用户，判断是否可以去除该指针
  			  2）如果客户使用了取值函数，先运用Self Encapsulate Field将待删除属性自我封装起来，
  			  	然后使用Substitute Algorithm对付取值函数，令它不再使用该属性。然后编译，测试
  			  3）如果客户并未使用取值函数，那就直接修改待删除属性的所有被引用点，
  			  	改以其他途径获得该属性所保存的对象。每次修改后，编译并测试
			  4）如果已经没有任何函数使用待删除属性，移除所有对该属性的更新逻辑，然后移除该属性
			  5）编译，测试
    9. Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）
    	动机：有一个字面数值，带有特别含义
    	做法：1）声明一个常量，令其值为原本的魔法数值
    		  2）找出这个魔法数的所有引用点
    		  3）检查是否可以使用这个新声明的常量来替换该魔法数。如果可以，便以此常量替换
    		  4）编译
    		  5）所有魔法数都被替换完毕后，编译并测试。此时整个程序应该运转正常，就像没有做任何修改一样
	10. Encapsulate Field（封装属性）
		动机：类中存在public属性
		做法：1）为public属性提供取值/设值函数
			  2）找到这个类以外使用该属性的所有地点。如果客户只是读取该属性，就把引用替换为对取值函数的调用；
			  	如果客户修改了该属性值，就将此引用点替换为对设值函数的调用
		  	  3）每次修改之后，编译并测试
		  	  4）将属性的所有用户修改完毕后，把属性声明为private
		  	  5）编译，测试
  	11. Encapsulate Collection（封装集合）
  		动机：有个函数返回一个集合
  		做法：1）加入为集合添加/移除元素的函数
  			  2）将保存集合的属性初始化为一个空集合
  			  3）编译
  			  4）找出集合设值函数的所有调用者。你可以修改那个设值函数，让它使用上述新建立的“添加/移除元素”
  			  	函数；也可以直接修改调用端，改让它调用上述新建立的“添加/移除元素”函数
			  5）编译，测试
			  6）找出所有“通过取值函数获得集合并修改其内容”的函数。逐一修改这些函数，让它们改用添加/移除函数,
			  	每次修改后，编译并测试
		  	  7）修改完上述所有“通过取值函数获得集合并修改集合内容”的函数后，修改取值函数自身，
		  	  	使它返回该集合的一个只读副本
		  	  8）编译，测试
		  	  9）找出取值函数的所有用户，从中找出应该存在于集合所属对象内的代码。运用Extract Method和Move Method
		  	  	将这些代码移到宿主对象去
		  	  10）修改现有取值函数的名字，然后添加一个新取值函数，使其返回一个枚举。
		  	  	找出旧取值函数的所有被使用点，将它们都改为使用新取值函数
		  	  11）如果这一步跨度太大，你可以先使用Rename Method修改原取值函数的名称；
		  	  	再建立一个新取值函数用以返回枚举；最后再修改所有调用者，使其调用新取值函数
		  	  12）编译，测试
  	12. Replace Record with Data Class（以数据取代记录）
  		动机：从数据库读出的记录，应该创建一个接口类，用以处理这些外来数据
  		做法：1）新建一个类，表示这个记录
  			  2）对于记录中的每一项数据，在新建的类中建立对应的private属性，并提供相应的取值/设值函数
  	13. Replace Type Code with Class（以类取代类型码）
  		动机：符号名终究只是个别名，但会大大降低代码的可读性，从而成为bug之源
  		做法：1）为类型码建立一个类
  			  2）修改源类实现，让它使用上述新建的类
  			  3）编译，测试
  			  4）对于源类中每一个使用类型码的函数，相应建立一个函数，让新函数使用新建的类
  			  5）逐一修改源类用户，让他们使用新接口
  			  6）每修改一个用户，编译并测试
  			  7）删除使用类型码的旧接口，并删除保存旧类型码的静态变量
  			  8）编译，测试
	14. Replace Type Code with Subclasses（以子类取代类型码）
		动机：有一个不可变的类型码，它会影响类的行为
		做法：1）使用Self Encapsulate Field将类型码自我封装起来
			  2）为类型码的每一个数值建立一个相应的子类。在每个子类中复写类型码的取值函数，
			  	使其返回相应的类型码值
			  3）每建立一个新的子类，编译并测试
			  4）从超类中删除保存类型码的属性。将类型码访问函数声明为抽象函数
			  5）编译，测试
	15. Replace Type Code with State/Strategy（以State/Strategy 取代类型码）
		动机：有一个类型码，它会影响类的行为，但是无法通过继承手法消除它
		做法：1）使用Self Encapsulate Field将类型码自我封装起来
			  2）新建一个类，根据类型码的用途为它命名，这就是一个状态对象
			  3）为这个新类添加子类，每个子类对应一种类型码
			  4）在超类中建立一个抽象的查询函数，用以返回类型码。在每个子类中复写该函数，返回确切类型码
			  5）编译
			  6）在源类中建立一个属性，用以保存新建的状态对象
			  7）调整源类中负责查询类型码的函数，将查询动作转发给状态对象
			  8）调整源类中为类型码设置的函数，将一个恰当的状态对象子类赋值给“保存状态对象”的那个属性
			  9）编译，测试
	16. Replace Subclass with Fields（以属性取代子类）
		动机：各个子类的唯一差别只在“返回常量数据”的函数身上
		做法：1）对所有子类使用Replace Constructor with Factory Method
			  2）如果有任何代码直接引用子类，令它改而引用超类
			  3）针对每个常量函数，在超类中声明一个final属性
			  4）为超类声明一个protected构造函数，用以初始化这些新增属性
			  5）新建或修改子类构造函数，使它调用超类的新增构造函数
			  6）编译，测试
			  7）在超类中实现所有常量，令它们返回相应属性值，然后将该函数从子类中删掉
			  8）每删除一个常量函数，编译并测试
			  9）子类中所有的常量函数都被删除后，使用Inline Method将子类构造函数内联到超类的工厂函数中
			  10）编译，测试
			  11）将子类删掉
			  12）编译，测试
			  13）重复“内联构造函数、删除子类”函数，直到所有子类都被删除

VIII. 简化条件表达式
	1. Decompose Conditional（分解条件表达式）
		动机：有一个复杂的条件（if-then-else）语句
		做法：1）讲if段落提炼出来，构成一个独立函数
			  2）讲then段落和else段落都提炼出来，各自构成一个独立函数
	2. Consolidate Conditional Expression（合并条件表达式）
		动机：有一些列的条件测试，都得到相同结果
		做法：1）确定这些条件语句都没有副作用
			  2）使用适当的逻辑操作符，将一系列相关条件表达式合并为一个
			  3）编译，测试
			  4）对合并后的条件表达式实施Extract Method
	3. Consolidate Duplicate Conditional Fragments（合并重复的条件片段）
		动机：在条件表达式的每个分支上有着相同的一段代码
		做法：1）鉴别出“执行方式不随条件变化而变化”的代码
			  2）如果这些共通代码位于条件表达式起始处，就将它移到条件表达式之前
			  3）如果这些共通代码位于条件表达式尾端，就将它移到条件表达式之后
			  4）如果这些共通代码位于条件表达式中段，就需要观察共通代码之前或之后的代码是否改变了什么东西。
			  	如果有所改变，应该首先将共通代码向前或向后移动，移至条件表达式的起始或尾端，
			  	再以前面所述方法来处理
		  	  5）如果共通代码不止一条语句，应该首先使用Extract Method将共通代码提炼到一个独立函数中，
		  	  	再以前面所说的办法来处理
  	4. Remove Control Flag（移除控制标记）
  		动机：在一系列表达式中，某个变量带有“控制标记”的作用
  		做法：a. 对控制标记的处理，最显而易见的办法是使用break语句或continue语句
  				1）找出让你跳出这段逻辑的控制标记值
  			  	2）找出对标记变量赋值的语句，代以恰当的break语句或continue语句
  			  	3）每次替换后，编译并测试
  			  b. 在未能提供break和continue语句的编程语言中，可以使用下述方法
  			  	1）运用Extract Method，将整段逻辑提炼到一个独立函数中
  			  	2）找出让你跳出这段逻辑的控制标记值
  			  	3）找出对标记变量赋值的语句，代以恰当的return语句
  			  	4）每次替换后，编译并测试
  	5. Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式）
  		动机：函数中的条件逻辑使人难以看清正常的执行路径
  		做法：1）对于每个检查，放进一个卫语句
  			  2）每次将条件替换成卫语句后，编译并测试
    6. Replace Conditional with Polymorphism（以多态取代条件语句）
    	动机：条件表达式根据对象类型的不同而选择不同的行为
    	做法：1）如果要处理的条件表达式是一个更大函数中的一部分，首先对条件表达式进行分析，
    			然后使用Extract Method将它提炼到一个独立函数去
    		  2）如果有必要，使用Move Method将条件表达式放置到继承结构的顶端
    		  3）任选一个子类，在其中建立一个函数，使之覆写超类中容纳条件表达式的那个函数。
    		  	将与该子类相关的条件表达式分支复制到新建函数中，并对它进行适当调整
		  	  4）编译，测试
		  	  5）在超类中删掉条件表达式内复制了的分支
		  	  6）编译，测试
		  	  7）针对条件表达式的每个分支，重复上述过程，直到所有分支都被移到子类内的函数为止
		  	  8）将超类之中容纳条件表达式的函数声明为抽象函数
  	7. Introduce Null Object（引入Null对象）
  		动机：需要再三检查某对象是否为null
  		做法：1）为源类建立一个子类，使其行为就像是源类的null版本。在源类和null子类中，都加上isNull()函数，
  				前者的isNull()应该返回false，后者的isNull()应该返回true
			  2）编译
			  3）找出所有“索求源对象却获得一个null”的地方。修改这些地方，使它们改而获得一个空对象
			  4）找出所有“将源对象与null作比较”的地方。修改这些地方，使它们调用isNull()函数
			  5）编译，测试
			  6）找出这样的程序点：如果对象不是null，做A动作，否则做B动作
			  7）对于每一个上述地点，在null类中覆写A动作，使其行为和B动作相同
			  8）使用上述被覆写的动作，然后删除“对象是否等于null”的条件测试。编译并测试
	8. Introduce Assertion（引入断言）
		动机：某一段代码需要对程序状态作出某种假设
		做法：如果你发现代码假设某个条件始终为真，就加入一个断言明确说明这种情况

IX. 简化函数调用
	1. Rename Method（函数改名）
		动机：函数名称未能揭示函数的用途
		做法：1）检查函数签名是否被超类或子类实现过
			  2）声明一个新函数，将它命名为你想要的新名称。将旧函数的代码复制到新函数中，并进行适当调整
			  3）编译
			  4）修改旧函数，令它将调用转发给新函数
			  5）编译，测试
			  6）找出旧函数的所有被引用点，修改它们，令它们改而引用新函数。每次修改后，编译并测试
			  7）删除旧函数
			  8）编译，测试
	2. Add Parameter（添加参数）
		动机：某个函数需要从调用端得到更多信息
		做法：1）检查函数签名是否被超类或子类实现过。如果是，则需要针对每份实现分别进行下列步骤
		      2）声明一个新函数，名称与原函数相同，只是加上新添加参数。就旧函数代码复制到新函数中
			  3）编译，测试
			  4）修改旧函数，令它调用新函数
			  5）编译，测试
			  6）找出旧函数的所有被引用点，将他们全部修改为对新函数的引用。每次修改后，编译并测试
			  7）删除旧函数
			  8）编译，测试
	3. Remove Parameter（移除参数）
		动机：函数本体不再需要某个参数
		做法：1）检查函数签名是否被炒类或子类实现过，如果是，则需要针对每份实现分别进行些列步骤
			  2）声明一个新函数，名称与原函数相同，只是去除不必要的参数。将旧函数的代码复制到新函数中
			  3）编译，测试
			  4）修改旧函数，令它调用新函数
			  5）编译，测试
			  6）找出旧函数的所有被引用点，将它们全部修改为对新函数的引用。每次修改后，编译并测试
			  7）删除旧函数
			  8）编译，测试
	4. Separate Query from Modifier（将查询函数和修改函数分离）
		动机：某个函数既返回对象状态值，又修改对象状态
		做法：1）新建一个查询函数，令它返回的值与原函数相同
			  2）修改原函数，令它调用查询函数，并返回获得的结果
			  3）编译，测试
			  4）将调用原函数的代码改为调用查询函数。然后，在调用查询函数的那一行之前，加上对原函数的调用。
			  	每次修改后，编译并测试
			  5）将原函数的返回值改为void，并删掉其中所有的return语句
	5. Parameterize Method（令函数携带参数）
		动机：若干函数做了类似的工作，但在函数本体中却包含了不同的值
		做法：1）新建一个带有参数的函数，使它可以替换先前所有的重复性函数
			  2）编译
			  3）将调用旧函数的代码改为调用新函数
			  4）对所有旧函数重复上述步骤，每次替换后，修改并测试
	6. Replace Parameter with Explict Methods（以明确函数取代参数）
		动机：有一个函数，其中完全取决于参数值而采取不同行为
		做法：1）针对参数的每一种可能值，新建一个明确函数
			  2）修改条件表达式的每个分支，使其调用合适的新函数
			  3）修改每个分支后，编译并测试
			  4）修改原函数的每一个被调用点，改而调用上述的某个合适的新函数
			  5）编译，测试
			  6）所有调用端都修改完毕后，删除原函数
	7. Preserve Whole Object（保持对象完整）
		动机：从某个对象取出若干值，将它们作为某一次函数调用时的参数
		做法：1）对目标函数新添一个参数项，用以代表原数据所在的完整对象
			  2）编译，测试
			  3）判断哪些参数可被包含在新添的完整对象中
			  4）选择上述参数之一，将被调用函数中原来引用该参数的地方，
			  	改用调用新添加参数对象的相应取值函数
			  5）删除该项参数
			  6）编译，测试
			  7）针对所有可从完整对象中获得的参数，重复上述过程
			  8）删除调用端中那些带有被删除参数的代码
			  9）编译，测试
	8. Replace Parameter with Methods（以函数取代参数）
		动机：对象调用某个函数，并将所得结果作为参数，传递给另一个函数，而接受该参数的函数本身也能够调用前一个函数
		做法：1）如果有必要，将参数的计算过程提炼到一个独立函数中
			  2）将函数本体内引用该参数的地方改为调用新建的函数
			  3）每次替换后，修改并测试
			  4）全部替换完成后，使用Remove Parameter将该参数去掉
	9. Introduce Parameter Object（引入参数对象）
		动机：某些参数中是很自然地同时出现
		做法：1）新建一个类，用以表现你想替换的一组参数。将这个类设为不可变的。
			  2）编译
			  3）针对使用该组参数的所有函数，实施Add Parameter，传入上述新建类的实例对象，并将此参数值设为null
			  4）对于Data Clumps中的每一项（在此均为参数），从函数签名中移除，并修改调用端和函数本体，
			  	令它们都改而通过新的参数对象取得该值
			  5）每去除一个参数，编译并测试
			  6）将原先的参数全部去除之后，观察有无适当函数可以运用Move Method搬移到参数对象之中
	10. Remove Setting Method（移除设值函数）
		动机：类中的某个属性应该在对象创建时被设值，然后就不再改变
		做法：1）检查设值函数被使用的情况，看它是否只被构造函数调用，或者被构造函数所调用的另一个函数调用
			  2）修改构造函数，使其直接访问设值函数所针对的那个变量
			  3）编译，测试
			  4）移除这个设值函数，将它所针对的属性设为final
			  5）编译，测试
	11. Hide Method（隐藏函数）
		动机：有一个函数，从来没有被其他任何类用到
		做法：1）经常检查有没有可能降低某函数的可见度
			  2）尽可能降低所有函数的可见度
			  3）每完成一组函数的隐藏之后，编译并测试
	12. Replace Constructor with Factory Method（以工厂函数取代构造函数）
		动机：希望在创建对象时，不仅仅是做简单的构建动作
		做法：1）新建一个工厂函数，让它调用现有的构造函数
			  2）将调用构造函数的代码改为调用工厂函数
			  3）每次替换后，编译并测试
			  4）将构造函数声明为private
			  5）编译
	13. Encapsulate Downcast（封装向下转型）
		动机：某个函数返回的对象，需要由函数调用者执行向下转型
		做法：1）找出必须对函数调用结果进行向下转型的地方
			  2）将向下转型动作搬移到该函数中
	14. Replace Error Code with Exception（以异常取代错误码）
		动机：某个函数返回一个特定的代码，用以表示某种错误情况
		做法：a. 函数调用者唯一
				1）决定应该抛出受控异常还是非受控异常
			 	2）找出该函数的所有调用者，对它们进行相应调整，使它们使用异常
			  	3）修改该函数的签名，令它反映出新用法
			  b. 如果函数调用者居多，上述修改过程可能跨度太大，可以采用如下步骤
			  	1）决定应该抛出受控异常还是非受控异常
			  	2）新建一个函数，使用异常来表示错误状况，将旧函数的代码复制到新函数中，
			  		并作适当调整
			  	3）修改旧函数的函数本体，让它调用上述新建函数
			  	4）编译，测试
			  	5）逐一修改就函数的调用者，令其调用新函数。每次修改后，编译并测试
			  	6）移除旧函数
	15. Replace Exception with Test（以测试取代异常）
		动机：面对一个调用者可以预先检查的条件，却抛出了异常
		做法：1）在函数调用点之前，放置一个测试语句，将函数内catch区段中的代码复制到测试句的适当if分支中
			  2）在catch区段起始处加入一个断言，确保catch区段绝对不会被执行
			  3）编译测试
			  4）移除所有catch区段，然后将try区段内的代码复制到try之外，然后移除try区段
			  5）编译，测试
X. 处理概括关系
	1. Pull Up Field（属性上移）
		动机：两个子类拥有相同的属性
		做法：1）针对待提升之属性，检查它们所有被使用点，确认它们以同样的方式被使用
			  2）如果这些属性的名称不同，先将它们改名，使每一个名称都和你想为超类属性取的名字相同
			  3）编译，测试
			  4）在超类中新建一个属性
			  5）移除子类中的属性
			  6）编译，测试
			  7）考虑对超类的新建属性使用Self Encapsulate Field
	2. Pull Up Method（函数上移）
		动机：有些函数，在各个子类中产生完全相同的结果
		做法：1）检查待提升函数，确定它们是完全一致的
			  2）如果待提升函数的签名不同，将那些签名都修改为你想要在超类中使用的签名
			  3）在超类中新建一个函数，将某一个待提升函数的代码复制到其中，做适当调整，然后编译
			  4）移除一个待提升的子类函数
			  5）编译，测试
			  6）逐一移出待提升的子函数，直到只剩下超类中的函数为止。每次移除之后都需要测试。
			  7）观察该函数的调用者，看看是否可以改为使用超类类型的对象
	3. Pull Up Constructor Body（构造函数本体上移）
		动机：在各个子类中拥有一些构造函数，它们的本体几乎完全一致
		做法：1）在超类中定义一个构造函数
			  2）将子类构造函数中的共同代码搬移到超类构造函数中
			  3）将子类构造函数中的共同代码删掉，改而调用新建的超类构造函数
			  4）编译，测试
	4. Push Down Method（函数下移）
		动机：超类中的某个函数只与部分子类有关
		做法：1）在所有子类中声明该函数，将超类中的函数本体复制到每一个子类函数中
			  2）删除超类中的函数
			  3）编译，测试
			  4）将该函数从所有不需要它的那些子类中删掉
			  5）编译，测试
	5. Push Down Field（函数下移）
		动机：超类中的某个属性只被部分子类用到
		做法：1）在所有子类中声明该属性
			  2）将该属性从超类中移除
			  3）编译，测试
			  4）将该属性从所有不需要它的那些子类中删掉
			  5）编译，测试
	6. Extract Subclass（提炼子类）
		动机：类中的某些特性只被某些实例用到
		做法：1）为源类定义一个新的子类
			  2）为这个新的子类提供构造函数
			  3）找出调用超类构造函数的所有地点。如果它们需要的是新建的子类，令它们改而调用新构造函数
			  4）逐一使用Push Down Method和Push Down Field将源类的特性移到子类去
			  5）找到所有这样的属性：它们所传达的信息如今可由继承体系自身传达。Self Encapsulate Field
			  	避免直接使用这些属性，然后将它们的取值函数替换为多态常量函数。所有使用这些属性的地方
			  	应该以Replace Conditional with Polymorphism重构
		  	  6）每次下移之后，编译并测试
  	7. Extract Superclass（提炼超类）
  		动机：两个类有相似特性
  		做法：1）为原本的类新建一个空白的抽象超类
  			  2）运用Pull Up Field、Pull Up Method和Pull Up Constructor Body逐一将子类的共同元素上移至超类
  			  3）每次上移后，编译并测试
  			  4）检查留在子类中的函数，看它们是否还有共通成分。如果有，可以使用Extract Method
  			  	将共通部分再提炼出来，然后使用Pull Up Method将提炼出的函数上移到超类。如果某个子类中某个
  			  	函数的整体流程很相似，你也许可以使用Form Template Method
			  5）将所有共通元素都上移到超类之后，检查子类的所有用户。如果它们只使用共同接口，
			  	你就可以把它们请求的对象类型改为超类
  	8. Extract Interface（提炼接口）
  		动机：若干客户使用类接口中的同一子集，或者两个类的接口有部分相同
  		做法：1）新建一个空接口
  			  2）在接口中声明待提炼类的共通操作
  			  3）让相关的类实现上述接口
  			  4）调整客户端的类型声明，令其使用该接口
	9. Collapse Hierarchy（折叠继承体系）
		动机：超类和子类之间无太大区别
		做法：1）选择你想要移除的类：超类还是子类
			  2）使用Pull Up Field和Pull Up Method，或者Push Down Method和Push Down Field，
			  	把想要移除的类的所有行为和数据搬移到另一个类
			  3）每次移动后，编译并测试
			  4）调整即将被移除的那个类的所有引用点，令它们改而引用合并后留下的类。
			  	这个动作将会影响变量的声明、参数的类型以及构造函数
		  	  5）移除我们的目标；此时的它应该已经成为一个空类
		  	  6）编译，测试
  	10. Form Template Method（塑造模板函数）
  		动机：你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同
  		做法：1）在各个子类中分解目标函数，使分解后的各个函数要不完全相同，要不完全不同
  			  2）运用Pull Up Method将各子类内完全相同的函数上移至超类
  			  3）对于那些完全不同的函数，实施Rename Method，使用这些函数的签名完全相同
  			  4）修改上述所有签名后，编译并测试
  			  5）运用Pull Up Method将所有原函数逐一上移至超类。
  			  	在超类中将那些代表各种不同操作的函数定义为抽象函数
  			  6）编译，测试
  			  7）移除其他子类中的原函数，每删除一个，编译并测试
	11. Replace Inheritance with Delegation（以委托取代继承）
		动机：某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据
		做法：1）在子类中新建一个属性，使其引用超类的一个实例，并将它初始化为this
			  2）修改子类内的所有函数，让它们不再使用超类，转而使用上述那个受托属性。每次修改后，编译并测试
			  3）去除两个类之间的继承关系，新建一个受托类的对象付给受托属性
			  4）针对客户端所用的每一个超类函数，为它添加一个简单的委托函数
			  5）编译，测试
	12. Replace Delegation with Inheritance（以继承取代委托）
		动机：在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数
		做法：1）让委托成为受托端的一个子类
			  2）编译
			  3）将受托属性设为该属性所处对象本身
			  4）去掉简单的委托函数
			  5）编译并测试
			  6）将所有其他涉及委托关系的代码，改为调用对象自身
			  7）移除受托属性
XI. 大型重构
	1. Tease Apart Inheritance（梳理并分解继承体系）
		动机：某个继承体系同时承担两项责任
		做法：1）首先识别出继承体系所承担的不同责任，然后建立一个二维表格，并以坐标轴表示出不同的任务。
				重复运用本重构，处理两个或两个以上的维度
			  2）判断哪一项责任更重要些，并准备将它留在当前的继承体系中。准备将另一项责任移到另一个继承体系中
			  3）使用Extract Class从当前的超类提炼出一个新类，用以表示重要性稍低的责任，
			  	并在原超类中添加一个实例变量，用以保存新类的实例
			  4）对应于原继承体系中的每个子类，创建上述新类的一个子类。在原继承体系的子类中，
			  	将前一步骤所添加的实例变量初始化为新建子类的实例
		  	  5）针对原继承体系中的每个子类，使用Move Method将其中的行为搬移到与之对应的新建子类中
		  	  6）当原继承体系中某个子类不再有任何代码时，就将它去除
		  	  7）重复以上步骤，直到原继承体系中的所有子类都被处理过为止。观察新继承体系，
		  	  	看看是否有可能对它实施其他重构手法，例如Pull Up Method或Pull Up Field
	2. Convert Procedural Design to Objects（将过程化设计转化为对象设计）
		动机：有一些传统过程化风格的代码
		做法：1）针对每一个记录类型，将其转变为只含访问函数的哑数据对象
			  2）针对每一处过程化风格，将该处的代码提炼到一个独立类中
			  3）针对每一段长长的程序，实施Extract Method及其他相关重构将它分解。
			  	再以Move Method将分解后的函数分别移到它所相关的哑数据类中
			  4）重复上述步骤，直到原始类中的所有函数都被移除。如果原始类是一个完全过程化的类，
			  	将它拿掉将大快人心
  	3. Separate Domain from Presentation（将领域和表述/显示分离）
  		动机：某些GUI类之中包含了领域逻辑
  		做法：1）为每个窗口新建一个领域类
  			  2）如果窗口内有一张表格，新建一个类来表示其中的行，
  			  	再以窗口所对应之领域类中的一个集合来容纳所有的行领域对象
  			  3）检查窗口中的数据。如果数据只被用于UI，就把它留着；如果数据被领域逻辑使用，
  			  	而且不显示于窗口上，我们就以Move Field将它搬移到领域类中；如果数据同时被UI和领域逻辑使用，
  			  	就对它实施Duplicate Observed Data，使它同时存在于两处，并保持两处之间的同步
  			  4）检查展现类中的逻辑。实施Extract Method将展现逻辑从领域逻辑中分开。一旦隔离了领域逻辑，
  			  	再运用Move Method将它移到领域类
  			  5）以上步骤完成后，你就拥有了两组彼此分离的类：展现类用以处理GUI，领域类包含所有业务逻辑。
  			  	此时的领域类组织可能还不够严谨，更进一步的重构将解决这些问题
  	4. Extract Hierarchy（提炼继承体系）
  		动机：某个类做了太多工作，其中一部分工作是以大量条件表达式完成的
  		做法：a. 无法确定哪些地方会发生变化
				1）鉴别出一种变化情况
				2）针对这种变化情况，新建一个子类，并对原始类实施Replace Constructor with Factory Method。
					再修改工厂函数，令它返回适当的子类实例。
				3）将含有条件逻辑的函数，一次一个，逐一复制到子类，然后在明确情况下，简化这些函数
				4）重复上述函数，将所有变化情况都分离出来，直到可以将超类声明为抽象类为止
				5）删除超类中那些被所有子类覆写的函数本体，并将他们声明为抽象函数
			  b. 清楚原始类会有哪些变化情况
			  	1）针对原始函数的每一种变化情况，建立一个子类
			  	2）使用Replace Constructor with Factory Method将原始类的构造函数转变为工厂函数，
			  		并令它针对每一种变化情况返回适当的子类实例
		  		3）针对带有条件逻辑的函数，实施Replace Conditional with Polymorphism。
		  			如果并非整个函数的行为有所变化，而只是函数一部分有所变化，
		  			先运用Extract Method将变化部分和不变部分隔开来
