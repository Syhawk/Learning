《代码简洁之道》
I. 函数
	1. 函数第一规则是要短小，第二条规则是还要短小。
	2. 函数应该做一件事。做好这件事。只做这一件事。
		判断方法：能否再拆除一个函数。
	3. 让代码拥有自顶向下的阅读顺序。
	4. switch语句很难短小。改为抽象工厂方法确实可以，但不总是适宜。
	5. 让每个例程都让你深合己意为止。
	6. 函数参数尽量的少。
		1）参数不易对付，概念性太多。
		2）难以测试。
		3）输入参数比输出参数还要难以理解。
	7. 参数规约：输入在前，输出在后。expected在前，actual在后。
	8. 函数名字命名：动词或者动词短语，恰好描述参数顺序和意图以及功能。
	9. 且可不要出现副作用。
		副作用：函数承诺只做一件事，其他事情被隐藏起来继续执行。
	10.函数要么做什么事，要么回答什么事，不可兼得。
	11.try catch替代返回错误码。需要把错误处理与正常流程分离。
	12.函数应该遵循迪杰斯特拉结构化编程规则：一个入口，一个出口。
		即，一个return，不能有break，continue，永远不能有goto。
		实际情况可以出现多个return、break、continue，绝对不能有goto。

II. 注释
	1. 程序员应当负责将注释保持在可维护、有关联、精确的高度。
	2. 写注释的常见动机之一是糟糕代码的存在。
	3. 有些注释是必须的，也是有利的（用于警告其他程序员会出现某种后果的注释）。
	4. 使用TODO形式用来放置要做的工作列表。
	5. 注释多余、不够精确、没有任何价值、注释的代码、无关性代码注释是禁止的。
	6. 注释要让读者以最短时间内理解注释所述何物。

III. 格式
	1. 每个程序员代码格式需良好统一。
	2. 每组代码行展示一条完整的思路，思路之间用空行分割。
	3. 关系密切的概念应该相互靠近。
		1）变量声明尽可能靠近其使用位置。
		2）Java实体变量声明在顶部，C++声明在底部。
			重点是声明地方能让每个人都知道。
	4. 被调用的函数应该放在执行调用的函数下面。
	5. 每个文件的代码行数不易过多（最多500行为宜）。
	6. 每行代码字符数目不要超过120个字符。
	7. 适当缩进，体现层级关系；使用空格和逗号字符加强分割效果。
	8. 循环体为空尽量不要出现，否则最好用括号包裹起来。
	9. 个人代码风格遵从团队风格。

IV. 对象和数据结构
	1. 以最好的方式呈现某个对象包含的数据，不要随便乱加getXXX和setXXX。
	2. 对象把数据隐藏于抽象之后，暴露操作数据的函数；数据结构暴露其数据，没有提供有意义的函数。
	3. 过程式代码（使用数据结构的代码）便于在不改变既有数据结构的前提下添加新函数；
		面向对象代码便于在不改变既有函数的前提下添加新类。
	4. 过程式代码难以添加新的数据结构，因为必须修改所有函数；
		面向对象代码难以添加新函数，因为必须修改所有类。
	5. 得墨忒耳率——类C的方法f只应该调用以下对象的方法：
		C、由f创建的对象、作为参数传递给f的对象、由C的实体变量持有的对象。
	6. 数据结构只拥有公共变量，对象则拥有私有变量和公共函数，那么得墨忒耳率就变得很适宜。
	7. 一半是对象，一半是数据结构，这样的类设计既增加了添加新函数的难度，也增加添加新数据结构的难度。

V. 错误处理
	1. 错误处理很重要，如果它搞乱了代码逻辑，就是错误的做法。
	2. 可控的异常代码就是违反开放/闭合原则，就得在catch语句和抛出异常之处的每个方法签名中声明该异常。
	3. 抛出的每个异常，应当提供足够的环境说明，以便判断错误的来源和处所。
	4. 打包一个第三方API，就降低了对它的依赖；未来就可以不太痛苦的改用其他代码库。
	5. 特例模式：创建一个类或配置一个对象，用来处理特例。
	6. 避免传递null值，避免NUllPointerException的出现，这会增加工作量。
	7. 将错误处理隔离看待，独立于主逻辑之外，就能写出强固而整洁的代码。

VI. 边界
	1. 使用类似Map这样的边界接口，就把它保留在类或近亲类中，避免从公共API中返回边界接口，
		或将边界接口作为参数传递给公共API。
	2. 不要在生产代码中试验新东西，而是编写测试来遍览和理解第三方代码——学习性测试。
	3. 学习性测试是一种精确试验，帮助我们增进对API的理解。
	4. 使用适当的FakeXXX，我们就能测试YYYController类。
		在拿到XXXAPI时，我们也能创建确保正确使用API的边界测试。

VII. 单元测试
	1. TDD（Test-Driven Development）三定律：
		1）在编写不能通过的单元测试前，不可编写生产代码。
		2）只可编写刚好无法通过的单元测试，不能编译也算不通过。
		3）只可编写刚好足以通过当前失败测试的生产代码。
	2. 测试代码和生产代码一样重要。
	3. 在单元测试中，可读性甚至比在生产代码中还重要。
	4. 测试代码应当满足这样的模式：构造——操作——检验（BUILD-OPERATE-CHECK）。
		第一个环节构造测试数据；第二个环节操作测试数据；第三个环节环节检验操作是否得到期望的结果。
	5. 测试代码应当简单、精悍、足具表达力，而且应该和生产代码一样有效。
	6. 每个测试函数的断言应该最小化，这些测试都可归结为一个快速方便理解的结论。
	7. 快速（Fast）：测试应该足够快。
		独立（Independent）：测试应该相互独立。
		可重复（Repeatable）：测试应当可在任何环境中重复通过。
		自足验证（Self-Validating）：测试应该有布尔值输出。
		及时（Timely）：测试应及时编写。

VIII. 类
	1. 公共静态常量-私有静态变量-私有实体变量-公共函数（Java）
	2. 类应该短小，用大概最多25个词简要描述一个类。
	3. 单一职责原则（SRP）：类或模块应有且只有一条加以修改的理由。
	4. 系统应该有许多短小的类而不是少量巨大的类组成。
		每个类封装一个权责，只有一个修改的原因，协同达成期望系统行为。
	5. 重构后的程序会采用更长、更有描述性的变量名；
		重构后的程序将函数和类声明当作给代码添加注释的一种手段；
		采用空格和格式技巧让程序更可读。
	6. 开放-闭合原则（OCP）：类应当对扩展开放，对修改封闭。
	7. 依赖倒置原则（DIP）：类应当依赖于抽象而不是依赖于具体细节。

IX. 系统
	1. 复杂要人命。它消磨开发者的时间，让产品难以规划、构建和测试。
	2. 依赖注入（DI），控制反转（IoC）：实现分离构造与使用。
	3. 面向方面编程（AOP）：恢复横贯式关注面模块化的普适手段。
		方面模块构造：指明了系统中哪些点的行为会以某种一致的方式被修改，从而支持某种特定的场景。
	4. 最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯Java（或其他语言）对象实现。
		不同的领域之间用最不具有侵害性的方面或类方面工具整合起来。这种架构能测试驱动，就像代码一样。
	5. 延迟决策：能够基于最有可能的信息做出选择。
	6. 标准使得易于复用想法和组件、雇佣拥有相关经验的人才...创立标准要贴近真实需求，且花费时间不能太长。
	7. 无论是设计系统或单独的模块，使用大概可工作的最简单方案。

X. 迭进
	1. 简单设计四条规则：
		1）运行所有测试；2）不可重复；3）表达了程序员的意图；4）尽可能减少类和方法的数量。
	2. 测试消除了对清理代码就会破坏代码的恐惧。
	3. 使用类和函数的数量尽量少是很重要的，但更重要的却是测试、消除重复和表达力。

XI. 并发编程
	1. 并发会在性能和编写额外代码上增加一些开销。
		正确的并发是复杂的，即便对于简单的问题也是如此。
		并发缺陷并非总能重现，所以常被看做偶发事件而忽略，未被当做真的缺陷看待。
		病发常常需要对设计策略的根本性修改。
	2. 单一职责原则（SRP，并发防御原则）：
		1）并发相关代码有自己的开发、修改和调优生命周期。
		2）并发相关代码有自己要对付的挑战，和非并发相关代码不同，而且往往更加困难。
		3）即便没有周边应用程序增加的负担，写的不好的并发代码可能的出错方式数量也已经足具挑战性。
		建议：分离并发相关代码与其他代码。
	3. 推论：限制数据作用域（并发防御原则）：
		1）会忘记保护一个或多个临界区——破坏了修改共享数据的代码。
		2）得多花力气保证一切都受到有效防护（破坏了DRY原则）。
		3）很难找到错误源，也很难判断错误源。
		建议：谨记数据封装；严格限制对可能被共享的数据的访问。
	4. 推论：使用数据复本（并发防御原则）：
		避免共享数据的好方法之一就是一开始就避免共享数据。
	5. 推论：线程应尽可能的独立（并发防御原则）：
		让每个线程在自己的世界中存在，不与其他线程共享数据。
	6. Java代码编写注意事项：
		1）实用类库提供的线程安全群集。
		2）使用executor框架（executor framework）执行无关任务（Java 5）。
		3）尽可能使用非锁定解决方案。
		4）有几个类并不是线程安全的。
	7. 三种典型并发模型：
		1）生产者——消费者模型；2）读者——作者模型；3）哲学家就餐模型。
	8. 使用一个共享对象多个方法（尽量避免）手段：
		1）基于客户端的锁定——客户端代码在调用第一个方法前锁定服务器，确保锁的范围覆盖了调用最后一个方法的代码
		2）基于服务端的锁定——在服务端内创建锁定服务端的方法，调用所有方法，然后解锁。让客户端代码调用新方法
		3）适配服务端——创建执行锁定的中间层。这是一种基于服务端的锁定的例子，但不修改原始服务端代码
	9. 尽可能减少同步区域。尽早考虑线程关闭问题，尽早令其工作正常。这会花费比你预期更多的时间。
	10. 测试线程代码：
		1）将伪失败看做可能的线程问题。
		2）先使非线程代码可工作。
		3）编写可插拔的线程代码。
		4）编写可调整的线程代码。
		5）运行多于处理器数量的线程。
		6）在不同平台上运行。
		7）调整代码并强迫错误发生。
	11. 1）不要将系统错误归咎于偶发事件。2）不要同时追踪非线程缺陷和线程缺陷，确保代码在线程之外工作。

XII. 总结
	1. 注释
		1）让注释传达本该更好的在源代码控制系统、问题追踪系统或任何其他记录系统中保存的信息，是不恰当的
		2）过时、无关或不正确的注释就是废弃的注释
		3）如果注释描述的是某种充分自我描述了的东西，那么注释就是多余的
		4）值得编写的注释也值得好好写
		5）不要有被注释的代码
	2. 环境
		1）构建系统应该是单步的小操作
		2）应当能够发出单个指令就可以运行全部单元测试
	3. 函数
		1）参数的参数数量应该尽量少
		2）输出参数违反直觉
		3）布尔值参数令人迷惑，应当少用
		4）永不被调用的方法应该丢弃
	4. 一般性问题
		1）尽量减少源文件中额外语言的数量和范围
		2）明显行为要被实现
		3）不正确的边界行为应保证正确性
		4）不要忽视安全，例如：编译警告
		5）代码不要重复
		6）所有较低层级概念放在派生类中，所有较高层级概念放在基类中
		7）积累应该对派生类一无所知
		8）类中方法越少越好，函数知道的变量越少越好，类拥有的实体变量越少越好
		9）删除死代码（永远不被执行的代码）
		10）变量和函数应该在靠近被使用的地方定义
		11）变量命名前后一致
		12）没有用到的变量，从不调用的函数，没有信息量的注释等等，都是应该被移除的废物
		13）不相互依赖的东西不该耦合
		14）类的方法是应对其所属类中的变量和函数感兴趣，不该垂青于其它类中的变量和函数
		15）选择性算子（布尔值、枚举、整数）尽量不要出现在函数中
		16）联排表达式、匈牙利语标记法和魔术数字都遮蔽了作者的意图
		17）代码应该放在读者自然而然期待它所在的地方，方法之一是看函数名称
		18）静态方法与多态行为正好相反，慎重选择
		19）使用解释性变量
		20）函数名称应该表达其行为
		21）代码要简洁、易解
		22）逻辑依赖改用物理依赖
		23）用多态替代if/else或switch/case
		24）每个团队都应遵循基于通用行业规范的一套编码标准
		25）用命名常量替代魔术数
		26）在代码中做决定时，确认自己足够准确
		27）坚守结构甚于约定的设计决策。命名约定很好，但却次于强制性结构
		28）应该把解释了条件意图的函数抽离出来
		29）否定式要比肯定式难明白一些
		30）函数值该做一件事
		31）排列函数参数，好让它们被调用的次序显而易见
		32）代码结构不要写的太随意
		33）把处理边界条件的代码集中到一处，不要散落于代码中
		34）函数中的语句应该在同一抽象层级上，该层级应该是函数名所示操作的下一层
		35）在较高层级放置可配置数据
		36）不要让某个模块了解太多其协作者的信息（得墨忒耳率）
	5. Java
		1）import导入尽量不要使用通配符
		2）常量不要继承
		3）常量与枚举慎重选择
	6. 名称
		1）取名不要太快，确认名称具有描述性
		2）不要取沟通实现的名称，取反映类或函数抽象层级的名称
		3）尽可能使用标准命名法
		4）不要使用混淆函数或变量意义的名称
		5）为较大作用范围选用较长名称
		6）不要使用匈牙利语命名法污染你的名称
		7）名称应该说明函数、变量或类个一切信息
	7. 测试
		1）只要还有没被测试探测过的条件，或是还有没被验证过的计算，测试就还不够
		2）使用覆盖率工具进行测试
		3）不要略过小测试
		4）被忽略的测试就是对不确定事物的疑问
		5）特别注意测试边界条件
		6）在某个函数发现一个缺陷时，最好全面测试那个函数
		7）用失败的测试用例来诊断问题所在
		8）测试应该能够被快速运行

XIII. 并发编程
	1. 服务器代码职权：
		1）套接字连接管理
		2）客户端处理
		3）线程策略
		4）服务器关闭策略
	2. 根据Java内存模型，32位值的赋值操作时不可中断的
	3. 安全性判断：
		1）什么地方有共享对象/值
		2）哪些代码会导致并发读/写问题
		3）如何防止这种并发问题发生
	4. 线程并发问题：
		1）容忍问题
		2）修改客户代码解决问题：基于客户代码的锁定
			注：这种策略有风险，因为使用服务端的程序员都得记住在使用前上锁、用过后解锁
		3）修改服务端代码解决问题，同时也修改了客户代码：基于服务端的锁定
			注：a. 减少了重复代码
				b. 提升了性能
				c. 减少了出错的可能性
				d. 执行了单一策略
				e. 缩减了共享变量的作用范围
	5. 加锁/同步的代码块数量要尽量少
	6. 死锁条件：
		1）互斥条件
		2）请求与保持
		3）不剥夺条件
		4）循环等待
